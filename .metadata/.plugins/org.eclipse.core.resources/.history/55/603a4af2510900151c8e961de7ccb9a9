/**
 * 
 */
package com.gdc.nms.server;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.gdc.nms.common.NagiosFileParser;
import com.gdc.nms.common.Pair;
import com.gdc.nms.common.QueryExecutor;
import com.gdc.nms.common.TransientConnectionProvider;
import com.gdc.nms.common.licensing.Licenses;
import com.gdc.nms.model.Device;
import com.gdc.nms.model.Device.Type;
import com.gdc.nms.model.DeviceResource;
import com.gdc.nms.model.Interface;
import com.gdc.nms.model.IpSla;
import com.gdc.nms.model.NmsProperty;
import com.gdc.nms.model.Property;
import com.gdc.nms.model.QosClass;
import com.gdc.nms.model.hyperic.Hyperic;
import com.gdc.nms.model.tran5ient.LogHistoryEntry;
import com.gdc.nms.server.agent.ConnectionAgent;
import com.gdc.nms.server.cli.CliProxyManager;
import com.gdc.nms.server.drivers.snmp.CiscoDriver;
import com.gdc.nms.server.drivers.snmp.Driver;
import com.gdc.nms.server.drivers.snmp.DriverManager;
import com.gdc.nms.server.drivers.snmp.Snmp3Connector;
import com.gdc.nms.server.drivers.snmp.SnmpConnectorException;
import com.gdc.nms.server.eclipselink.Persister;
import com.gdc.nms.server.eclipselink.SqlInsertableRowDescriptor;
import com.gdc.nms.server.hyperic.HypericServiceLocal;
import com.gdc.nms.server.licensing.LicenseValidator;
import com.gdc.nms.server.stats.StatsRetriever;

/**
 * Session Bean implementation class DeviceService
 */
@EJB(name = "DeviceServiceLocal", beanInterface = DeviceServiceLocal.class)
@Stateless
@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
public class DeviceServiceBean implements DeviceServiceRemote, DeviceServiceLocal {
    private static final Logger log = LoggerFactory.getLogger(DeviceServiceBean.class);

    private static final CliProxyManager CLI_PROXY_MANAGER = new CliProxyManager();

    @EJB(beanInterface = StatsServiceLocal.class)
    private StatsServiceLocal statsService;

    @Resource(name = "jdbc/NmsDatabasePool")
    private DataSource nmsDatabasePool;

    @EJB(beanInterface = EntityServiceLocal.class)
    private EntityServiceLocal entityService;

    @EJB(beanInterface = HypericServiceLocal.class)
    private HypericServiceLocal hypericService;

    @Override
    public Map<NmsProperty, Object> discoverDevice(Device device) throws SnmpConnectorException {
        Map<NmsProperty, Object> properties = null;
        Driver driver = DriverManager.getInstance().getDriver(device);

        try {
            properties = driver.discoverDevice();
        } finally {
            driver.unbind();
        }

        return properties;
    }

    @Override
    public Set<Interface> getInterfaces(Device device) throws SnmpConnectorException {
        Driver driver = DriverManager.getInstance().getDriver(device);
        Set<Interface> interfaces = null;
        try {
            interfaces = driver.getInterfaces();
        } finally {
            driver.unbind();
        }
        return interfaces;
    }

    @Override
    public String getSysOid(Device device) throws SnmpConnectorException {

        // Shitty patch to add those fkng ups which do not answer SysOID
        if (device.getType() == Device.Type.EMERSON_UPS) {
            return "1.3.6.1.4.1.32481";
        }else if(device.getType()==Device.Type.MOCK) {
        	return 
        }

        Driver driver = DriverManager.getInstance().getDriver(device);
        String sysOid = "";

        try {
            sysOid = driver.getSysOid();
        } finally {
            driver.unbind();
        }

        return sysOid;
    }

    @Override
    public String getHostname(Device device) throws SnmpConnectorException {
        Driver driver = DriverManager.getInstance().getDriver(device);
        String hostname = "";
        try {
            hostname = driver.getHostname();
        } finally {
            driver.unbind();
        }
        return hostname;
    }

    @Override
    public List<QosClass> getQosClasses(Device device, List<Integer> ifIndexes) throws SnmpConnectorException {
        List<QosClass> qosClasses = null;
        Driver driver = DriverManager.getInstance().getDriver(device);
        try {
            qosClasses = driver.getQosClasses(ifIndexes);
        } finally {
            driver.unbind();
        }
        return qosClasses != null ? qosClasses : new ArrayList<QosClass>(0);
    }

    @Override
    public Set<Integer> getIfIndexesWithQos(Device device) throws SnmpConnectorException {
        Set<Integer> ifIndexes = null;
        Driver driver = DriverManager.getInstance().getDriver(device);
        try {
            ifIndexes = driver.getIfIndexesWithQos();
        } finally {
            driver.unbind();
        }
        return ifIndexes;
    }

    @Override
    public Pair<Set<Interface>, Set<Integer>> getInterfacesAndIfIndexesWithQos(Device device)
            throws SnmpConnectorException {
        Driver driver = DriverManager.getInstance().getDriver(device);
        Set<Interface> interfaces = null;
        Set<Integer> ifIndexes = null;

        try {
            interfaces = driver.getInterfaces();
            ifIndexes = driver.getIfIndexesWithQos();
        } finally {
            driver.unbind();
        }

        return Pair.of(interfaces, ifIndexes);
    }

    @Override
    public List<IpSla> getIpSlas(Device device) throws SnmpConnectorException {
        List<IpSla> ipSlas = null;
        Driver driver = DriverManager.getInstance().getDriver(device);

        try {
            ipSlas = driver.getIpSlas();
        } finally {
            driver.unbind();
        }

        return ipSlas != null ? ipSlas : new ArrayList<IpSla>(0);
    }

    @Override
    public List<Pair<Integer, String>> discoverDeviceAuthenticationParameters(final Device device)
            throws SnmpConnectorException {
        Snmp3Connector snmp3Connector = new Snmp3Connector();

        try {
            snmp3Connector.open(device);
            return snmp3Connector.getAuthenticationParameters();
        } finally {
            snmp3Connector.close();
        }
    }

    @Override
    public String getName() {
        return NAME;
    }

    @Override
    public List<LogHistoryEntry> getLogHistory(Device device) throws SnmpConnectorException {
        List<LogHistoryEntry> entries = null;
        Driver driver = DriverManager.getInstance().getDriver(device);

        try {
            if (driver instanceof CiscoDriver) {
                entries = ((CiscoDriver) driver).getLogHistory();
            }
        } finally {
            driver.unbind();
        }

        return entries != null ? entries : new ArrayList<LogHistoryEntry>(0);
    }

    @Override
    public void gatherAndPersistStats(Device device) {
        StatsRetriever statsRetriever = DriverManager.getInstance().getStatsRetriever(device);

        if (statsRetriever != null) {
            try {
                List<SqlInsertableRowDescriptor> stats = statsRetriever.getStats();
                Persister statsPersister = new Persister(new QueryExecutor(new TransientConnectionProvider(
                    nmsDatabasePool)));

                try {
                    List<SqlInsertableRowDescriptor> missedDescriptors = statsPersister.persist(stats);

                    if (missedDescriptors != null) {
                        statsService.checkStatsTables(device.getSysObjectID(), device.getStatsTableId());
                        statsPersister.persist(missedDescriptors);
                    }
                } finally {
                    statsPersister.dispose();
                }
            } catch (Exception e) {
                log.error("error while persisting device " + device.getIp() + " stats", e);
            } finally {
                statsRetriever.dispose();
            }
        }
    }

    @Override
    public int getLatency(Device device) throws SnmpConnectorException {
        int latency = -1;
        Driver driver = DriverManager.getInstance().getDriver(device);

        try {
            latency = driver.getLatency(5000);
        } finally {
            driver.unbind();
        }

        return latency;
    }

    @Override
    public List<DeviceResource> getDeviceResources(Device device) throws SnmpConnectorException {

        List<DeviceResource> deviceResources = new LinkedList<DeviceResource>();

        if (device.isSnmpable()) {
            Driver driver = DriverManager.getInstance().getDriver(device);

            try {
                deviceResources.addAll(driver.getDeviceResources());
            } finally {
                driver.unbind();
            }
        }

        if (Hyperic.hasAgent(device)) {
            try {
                deviceResources.addAll(hypericService.getServers(device));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        if (device.getType() == Type.SERVER) {
            deviceResources.addAll(getNagiosResources(device.getAlias()));
        }

        return deviceResources;
    }

    private List<DeviceResource> getNagiosResources(String deviceAlias) {
        List<DeviceResource> deviceResource = new ArrayList<DeviceResource>();

        List<Property> path = entityService.getEntities(NagiosFileParser.NAGIOS_PATH_QUERY, Property.class, true, 0, 0);
        if (!path.isEmpty()) {
            Map<String, Map<String, Map<String, String>>> hostNameMap = NagiosFileParser.parseFile(path.get(0)
                .getValue());

            // get hostname service_description
            Map<String, Map<String, String>> serviceDescription = hostNameMap.get(deviceAlias);
            if (serviceDescription != null) {
                int index = 0;
                for (String serviceDescriptionName : serviceDescription.keySet()) {
                    deviceResource.add(new DeviceResource(index + "", serviceDescriptionName, 0,
                        DeviceResource.Type.NAGIOS_SERVICE));
                    index++;
                }
            }
        }
        return deviceResource;
    }

    @Override
    public boolean isAddingDeviceAllowed() {
        return ConnectionAgent.getInstance().getDeviceWrappersSize() < ((Integer) LicenseValidator.validate().get(
            Licenses.LICENSE_DEVICE_COUNT));
    }

    @Override
    public void openCli(long deviceId, String username, String password, String topic, int columns, int rows) {
        CLI_PROXY_MANAGER.openCli(entityService, deviceId, username, password, topic, columns, rows);
    }

    @Override
    public void closeCli(long deviceId, String topic) {
        CLI_PROXY_MANAGER.closeCli(deviceId, topic);
    }
}
